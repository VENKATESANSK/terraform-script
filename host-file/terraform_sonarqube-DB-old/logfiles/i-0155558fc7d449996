Starting Chef Client, version 13.7.16
resolving cookbooks for run list: ["java", "sonarqube::default"]
Synchronizing Cookbooks:
  - java (1.49.0)
  - apt (6.1.4)
  - windows (3.4.4)
  - ohai (5.2.2)
  - homebrew (4.3.0)
  - sonarqube (0.3.3)
Installing Cookbook Gems:
Compiling Cookbooks...
Converging 23 resources
Recipe: java::notify
  * log[jdk-version-changed] action nothing (skipped due to action :nothing)
Recipe: java::set_java_home
  * directory[/etc/profile.d] action create (up to date)
  * template[/etc/profile.d/jdk.sh] action create
    - create new file /etc/profile.d/jdk.sh
    - update content in file /etc/profile.d/jdk.sh from none to 5b75c4
    --- /etc/profile.d/jdk.sh	2018-02-26 10:50:29.112232969 +0000
    +++ /etc/profile.d/.chef-jdk20180226-8280-1cim5j3.sh	2018-02-26 10:50:29.112232969 +0000
    @@ -1 +1,2 @@
    +export JAVA_HOME=/usr/lib/jvm/java
    - change mode from '' to '0755'
    - restore selinux security context
Recipe: java::oracle
  * yum_package[tar] action install (up to date)
  * java_ark[jdk] action install
    - create dir /usr/lib/jvm and change owner to root:root
    * yum_package[curl for download_direct_from_oracle] action install (up to date)
    - download oracle tarball straight from the server
    - extract compressed data into Chef file cache path and
                        move extracted data to /usr/lib/jvm/jdk1.8.0_131
    - Symlink /usr/lib/jvm/jdk1.8.0_131 to /usr/lib/jvm/java
    * yum_package[curl for download_direct_from_oracle] action nothing (skipped due to action :nothing)
    * java_alternatives[set-java-alternatives] action set
      - Add alternative for appletviewer
      - Add alternative for ControlPanel
      - Add alternative for extcheck
      - Add alternative for idlj
      - Add alternative for jar
      - Add alternative for jarsigner
      - Add alternative for java
      - Add alternative for javac
      - Add alternative for javadoc
      - Add alternative for javafxpackager
      - Add alternative for javah
      - Add alternative for javap
      - Add alternative for javaws
      - Add alternative for jcmd
      - Add alternative for jconsole
      - Add alternative for jcontrol
      - Add alternative for jdb
      - Add alternative for jdeps
      - Add alternative for jhat
      - Add alternative for jinfo
      - Add alternative for jjs
      - Add alternative for jmap
      - Add alternative for jmc
      - Add alternative for jps
      - Add alternative for jrunscript
      - Add alternative for jsadebugd
      - Add alternative for jstack
      - Add alternative for jstat
      - Add alternative for jstatd
      - Add alternative for jvisualvm
      - Add alternative for keytool
      - Add alternative for native2ascii
      - Add alternative for orbd
      - Add alternative for pack200
      - Add alternative for policytool
      - Add alternative for rmic
      - Add alternative for rmid
      - Add alternative for rmiregistry
      - Add alternative for schemagen
      - Add alternative for serialver
      - Add alternative for servertool
      - Add alternative for tnameserv
      - Add alternative for unpack200
      - Add alternative for wsgen
      - Add alternative for wsimport
      - Add alternative for xjc
  
Recipe: java::notify
  * log[jdk-version-changed] action write
  
Recipe: sonarqube::default
  * group[sonarqube] action create
    - create group sonarqube
  * linux_user[sonarqube] action create
    - create user sonarqube
  * remote_file[/var/chef/cache/sonarqube-7.0.zip] action create
    - create new file /var/chef/cache/sonarqube-7.0.zip
    - update content in file /var/chef/cache/sonarqube-7.0.zip from none to 263942
    (file sizes exceed 10000000 bytes, diff output suppressed)
    - change mode from '' to '0644'
    - restore selinux security context
  * yum_package[unzip] action install
    - install version 6.0-16.el7 of package unzip
  * bash[unzip installation] action run
    - execute "bash"  "/tmp/chef-script20180226-8280-1xd0gm6"
  * directory[/opt/sonarqube-7.0/conf] action create
    - change mode from '0755' to '0700'
    - restore selinux security context
  * template[/opt/sonarqube-7.0/conf/sonar.properties] action create
    - update content in file /opt/sonarqube-7.0/conf/sonar.properties from 25cdab to 6a17ca
    --- /opt/sonarqube-7.0/conf/sonar.properties	2018-02-02 12:23:30.000000000 +0000
    +++ /opt/sonarqube-7.0/conf/.chef-sonar20180226-8280-1jvvmbb.properties	2018-02-26 10:51:07.416219248 +0000
    @@ -1,361 +1,189 @@
    -# Property values can:
    -# - reference an environment variable, for example sonar.jdbc.url= ${env:SONAR_JDBC_URL}
    -# - be encrypted. See https://redirect.sonarsource.com/doc/settings-encryption.html
    +# Generated by Chef for ip-10-0-1-78.ec2.internal
    +# Local modifications will be overwritten.
     
    +# This file must contain only ISO 8859-1 characters
    +# see http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Properties.html#load(java.io.InputStream)
    +#
    +# To use an environment variable, use the following syntax :  ${env:NAME_OF_ENV_VARIABLE}
    +# For example:
    +#   sonar.jdbc.url= ${env:SONAR_JDBC_URL}
    +#
    +#
    +# See also the file conf/wrapper.conf for JVM advanced settings
    +
     #--------------------------------------------------------------------------------------------------
     # DATABASE
     #
    -# IMPORTANT:
    -# - The embedded H2 database is used by default. It is recommended for tests but not for
    -#   production use. Supported databases are MySQL, Oracle, PostgreSQL and Microsoft SQLServer.
    -# - Changes to database connection URL (sonar.jdbc.url) can affect SonarSource licensed products.
    +# IMPORTANT: the embedded H2 database is used by default. It is recommended for tests only.
    +# Please use a production-ready database. Supported databases are MySQL, Oracle, PostgreSQL
    +# and Microsoft SQLServer.
     
    -# User credentials.
     # Permissions to create tables, indices and triggers must be granted to JDBC user.
     # The schema must be created first.
    -#sonar.jdbc.username=
    -#sonar.jdbc.password=
    +#sonar.jdbc.username=sonar
    +#sonar.jdbc.password=sonar
     
    -#----- Embedded Database (default)
    -# H2 embedded database server listening port, defaults to 9092
    -#sonar.embeddedDatabase.port=9092
    +sonar.jdbc.username=admin123
    +sonar.jdbc.password=password123
     
    -#----- MySQL 5.6 or greater
    -# Only InnoDB storage engine is supported (not myISAM).
    -# Only the bundled driver is supported. It can not be changed.
    -#sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&characterEncoding=utf8&rewriteBatchedStatements=true&useConfigs=maxPerformance&useSSL=false
    +#----- Embedded database H2
    +# Note: it does not accept connections from remote hosts, so the
    +# SonarQube server and the maven plugin must be executed on the same host.
     
    +# Database URL
    +#sonar.jdbc.url=jdbc:h2:tcp://localhost:9092/sonar
    +sonar.jdbc.url=jdbc:mysql://sonardbinstance.cm5sjo7cm7pi.us-east-1.rds.amazonaws.com:3306/sonar_poc?useUnicode=true&characterEncoding=utf8&rewriteBatchedStatements=true&useConfigs=maxPerformance&useSSL=false
     
    -#----- Oracle 11g/12c
    -# The Oracle JDBC driver must be copied into the directory extensions/jdbc-driver/oracle/.
    -# Only the thin client is supported, and only the versions 11.2.x or 12.2.x must be used. See
    -# https://jira.sonarsource.com/browse/SONAR-9758 for more details.
    -# If you need to set the schema, please refer to http://jira.sonarsource.com/browse/SONAR-5000
    -#sonar.jdbc.url=jdbc:oracle:thin:@localhost:1521/XE
    +# directory containing H2 database files. By default it's the /data directory in the SonarQube installation.
    +sonar.embeddedDatabase.dataDir=
    +# H2 embedded database server listening port, defaults to 9092
    +#sonar.embeddedDatabase.port=9092
     
    -
    -#----- PostgreSQL 8.x or greater
    -# If you don't use the schema named "public", please refer to http://jira.sonarsource.com/browse/SONAR-5000
    -#sonar.jdbc.url=jdbc:postgresql://localhost/sonar
    -
    -
    -#----- Microsoft SQLServer 2014/2016 and SQL Azure
    -# A database named sonar must exist and its collation must be case-sensitive (CS) and accent-sensitive (AS)
    -# Use the following connection string if you want to use integrated security with Microsoft Sql Server
    -# Do not set sonar.jdbc.username or sonar.jdbc.password property if you are using Integrated Security
    -# For Integrated Security to work, you have to download the Microsoft SQL JDBC driver package from
    -# https://www.microsoft.com/en-us/download/details.aspx?id=55539
    -# and copy sqljdbc_auth.dll to your path. You have to copy the 32 bit or 64 bit version of the dll
    -# depending upon the architecture of your server machine.
    -#sonar.jdbc.url=jdbc:sqlserver://localhost;databaseName=sonar;integratedSecurity=true
    -
    -# Use the following connection string if you want to use SQL Auth while connecting to MS Sql Server.
    -# Set the sonar.jdbc.username and sonar.jdbc.password appropriately.
    -#sonar.jdbc.url=jdbc:sqlserver://localhost;databaseName=sonar
    -
    -
     #----- Connection pool settings
    -# The maximum number of active connections that can be allocated
    -# at the same time, or negative for no limit.
    -# The recommended value is 1.2 * max sizes of HTTP pools. For example if HTTP ports are
    -# enabled with default sizes (50, see property sonar.web.http.maxThreads)
    -# then sonar.jdbc.maxActive should be 1.2 * 50 = 60.
    -#sonar.jdbc.maxActive=60
    +sonar.jdbc.maxActive=20
    +sonar.jdbc.maxIdle=5
    +sonar.jdbc.minIdle=2
    +sonar.jdbc.maxWait=5000
    +sonar.jdbc.minEvictableIdleTimeMillis=600000
    +sonar.jdbc.timeBetweenEvictionRunsMillis=30000
     
    -# The maximum number of connections that can remain idle in the
    -# pool, without extra ones being released, or negative for no limit.
    -#sonar.jdbc.maxIdle=5
     
    -# The minimum number of connections that can remain idle in the pool,
    -# without extra ones being created, or zero to create none.
    -#sonar.jdbc.minIdle=2
    -
    -# The maximum number of milliseconds that the pool will wait (when there
    -# are no available connections) for a connection to be returned before
    -# throwing an exception, or <= 0 to wait indefinitely.
    -#sonar.jdbc.maxWait=5000
    -
    -#sonar.jdbc.minEvictableIdleTimeMillis=600000
    -#sonar.jdbc.timeBetweenEvictionRunsMillis=30000
    -
    -
    -
     #--------------------------------------------------------------------------------------------------
     # WEB SERVER
    -# Web server is executed in a dedicated Java process. By default heap size is 512Mb.
    -# Use the following property to customize JVM options.
    -#    Recommendations:
    -#
    -#    The HotSpot Server VM is recommended. The property -server should be added if server mode
    -#    is not enabled by default on your environment:
    -#    http://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html
    -#
    -#    Startup can be long if entropy source is short of entropy. Adding
    -#    -Djava.security.egd=file:/dev/./urandom is an option to resolve the problem.
    -#    See https://wiki.apache.org/tomcat/HowTo/FasterStartUp#Entropy_Source
    -#
    -#sonar.web.javaOpts=-Xmx512m -Xms128m -XX:+HeapDumpOnOutOfMemoryError
     
    -# Same as previous property, but allows to not repeat all other settings like -Xmx
    -#sonar.web.javaAdditionalOpts=
    -
     # Binding IP address. For servers with more than one IP address, this property specifies which
     # address will be used for listening on the specified ports.
     # By default, ports will be used on all IP addresses associated with the server.
    -#sonar.web.host=0.0.0.0
    +sonar.web.host=0.0.0.0
     
     # Web context. When set, it must start with forward slash (for example /sonarqube).
     # The default value is root context (empty value).
    -#sonar.web.context=
    -# TCP port for incoming HTTP connections. Default value is 9000.
    -#sonar.web.port=9000
    +sonar.web.context=/sonar
     
    +# TCP port for incoming HTTP connections. Disabled when value is -1.
    +sonar.web.port=9000
     
    -# The maximum number of connections that the server will accept and process at any given time.
    -# When this number has been reached, the server will not accept any more connections until
    -# the number of connections falls below this value. The operating system may still accept connections
    -# based on the sonar.web.connections.acceptCount property. The default value is 50.
    -#sonar.web.http.maxThreads=50
    +# TCP port for incoming HTTPS connections. Disabled when value is -1 (default).
    +sonar.web.https.port=-1
     
    -# The minimum number of threads always kept running. The default value is 5.
    -#sonar.web.http.minThreads=5
    +# HTTPS - the alias used to for the server certificate in the keystore.
    +# If not specified the first key read in the keystore is used.
    +sonar.web.https.keyAlias=
     
    -# The maximum queue length for incoming connection requests when all possible request processing
    -# threads are in use. Any requests received when the queue is full will be refused.
    -# The default value is 25.
    -#sonar.web.http.acceptCount=25
    +# HTTPS - the password used to access the server certificate from the
    +# specified keystore file. The default value is "changeit".
    +sonar.web.https.keyPass=changeit
     
    -# By default users are logged out and sessions closed when server is restarted.
    -# If you prefer keeping user sessions open, a secret should be defined. Value is
    -# HS256 key encoded with base64. It must be unique for each installation of SonarQube.
    -# Example of command-line:
    -# echo -n "type_what_you_want" | openssl dgst -sha256 -hmac "key" -binary | base64
    -#sonar.auth.jwtBase64Hs256Secret=
    +# HTTPS - the pathname of the keystore file where is stored the server certificate.
    +# By default, the pathname is the file ".keystore" in the user home.
    +# If keystoreType doesn't need a file use empty value.
    +sonar.web.https.keystoreFile=
     
    -# The inactivity timeout duration of user sessions, in minutes. After the configured
    -# period of time, the user is logged out.
    -# The default value is set to 3 days (4320 minutes)
    -# and cannot be greater than 3 months. Value must be strictly positive.
    -#sonar.web.sessionTimeoutInMinutes=4320
    +# HTTPS - the password used to access the specified keystore file. The default
    +# value is the value of sonar.web.https.keyPass.
    +sonar.web.https.keystorePass=
     
    -# A passcode can be defined to access some web services from monitoring
    -# tools without having to use the credentials of a system administrator.
    -# Check the Web API documentation to know which web services are supporting this authentication mode.
    -# The passcode should be provided in HTTP requests with the header "X-Sonar-Passcode".
    -# By default feature is disabled.
    -#sonar.web.systemPasscode=
    +# HTTPS - the type of keystore file to be used for the server certificate.
    +# The default value is JKS (Java KeyStore).
    +sonar.web.https.keystoreType=JKS
     
    +# HTTPS - the name of the keystore provider to be used for the server certificate.
    +# If not specified, the list of registered providers is traversed in preference order
    +# and the first provider that supports the keystore type is used (see sonar.web.https.keystoreType).
    +sonar.web.https.keystoreProvider=
     
    -#--------------------------------------------------------------------------------------------------
    -# SSO AUTHENTICATION
    +# HTTPS - the pathname of the truststore file which contains trusted certificate authorities.
    +# By default, this would be the cacerts file in your JRE.
    +# If truststoreFile doesn't need a file use empty value.
    +sonar.web.https.truststoreFile=
     
    -# Enable authentication using HTTP headers
    -#sonar.web.sso.enable=false
    +# HTTPS - the password used to access the specified truststore file. 
    +sonar.web.https.truststorePass=
     
    -# Name of the header to get the user login.
    -# Only alphanumeric, '.' and '@' characters are allowed
    -#sonar.web.sso.loginHeader=X-Forwarded-Login
    +# HTTPS - the type of truststore file to be used.
    +# The default value is JKS (Java KeyStore).
    +sonar.web.https.truststoreType=JKS
     
    -# Name of the header to get the user name
    -#sonar.web.sso.nameHeader=X-Forwarded-Name
    +# HTTPS - the name of the truststore provider to be used for the server certificate.
    +# If not specified, the list of registered providers is traversed in preference order
    +# and the first provider that supports the truststore type is used (see sonar.web.https.truststoreType).
    +sonar.web.https.truststoreProvider=
     
    -# Name of the header to get the user email (optional)
    -#sonar.web.sso.emailHeader=X-Forwarded-Email
    +# HTTPS - whether to enable client certificate authentication.
    +# The default is false (client certificates disabled).
    +# Other possible values are 'want' (certificates will be requested, but not required),
    +# and 'true' (certificates are required).
    +sonar.web.https.clientAuth=false
     
    -# Name of the header to get the list of user groups, separated by comma (optional).
    -# If the sonar.sso.groupsHeader is set, the user will belong to those groups if groups exist in SonarQube.
    -# If none of the provided groups exists in SonarQube, the user will only belong to the default group.
    -# Note that the default group will always be set.
    -#sonar.web.sso.groupsHeader=X-Forwarded-Groups
    +# The maximum number of connections that the server will accept and process at any given time.
    +# When this number has been reached, the server will not accept any more connections until
    +# the number of connections falls below this value. The operating system may still accept connections
    +# based on the sonar.web.connections.acceptCount property. The default value is 50 for each
    +# enabled connector.
    +sonar.web.http.maxThreads=50
    +sonar.web.https.maxThreads=50
     
    -# Interval used to know when to refresh name, email and groups.
    -# During this interval, if for instance the name of the user is changed in the header, it will only be updated after X minutes.
    -#sonar.web.sso.refreshIntervalInMinutes=5
    +# The minimum number of threads always kept running. The default value is 5 for each
    +# enabled connector.
    +sonar.web.http.minThreads=5
    +sonar.web.https.minThreads=5
     
    +# The maximum queue length for incoming connection requests when all possible request processing
    +# threads are in use. Any requests received when the queue is full will be refused.
    +# The default value is 25 for each enabled connector.
    +sonar.web.http.acceptCount=25
    +sonar.web.https.acceptCount=25
     
    -#--------------------------------------------------------------------------------------------------
    -# COMPUTE ENGINE
    -# The Compute Engine is responsible for processing background tasks.
    -# Compute Engine is executed in a dedicated Java process. Default heap size is 512Mb.
    -# Use the following property to customize JVM options.
    -#    Recommendations:
    -#
    -#    The HotSpot Server VM is recommended. The property -server should be added if server mode
    -#    is not enabled by default on your environment:
    -#    http://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html
    -#
    -#sonar.ce.javaOpts=-Xmx512m -Xms128m -XX:+HeapDumpOnOutOfMemoryError
    +# Access logs are generated in the file logs/access.log. This file is rolled over when it's 5Mb.
    +# An archive of 3 files is kept in the same directory.
    +# Access logs are enabled by default.
    +sonar.web.accessLogs.enable=true
     
    -# Same as previous property, but allows to not repeat all other settings like -Xmx
    -#sonar.ce.javaAdditionalOpts=
    +# TCP port for incoming AJP connections. Disabled when value is -1.
    +sonar.ajp.port=9009
     
     
    -#--------------------------------------------------------------------------------------------------
    -# ELASTICSEARCH
    -# Elasticsearch is used to facilitate fast and accurate information retrieval.
    -# It is executed in a dedicated Java process. Default heap size is 512Mb.
    -#
    -# --------------------------------------------------
    -# Word of caution for Linux users on 64bits systems
    -# --------------------------------------------------
    -# Please ensure Virtual Memory on your system is correctly configured for Elasticsearch to run properly
    -# (see https://www.elastic.co/guide/en/elasticsearch/reference/5.5/vm-max-map-count.html for details).
    -#
    -# When SonarQube runs standalone, a warning such as the following may appear in logs/es.log:
    -#      "max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]"
    -# When SonarQube runs as a cluster, however, Elasticsearch will refuse to start.
    -#
     
    -# JVM options of Elasticsearch process
    -#sonar.search.javaOpts=-Xms512m \
    -# -Xmx512m \
    -# -XX:+HeapDumpOnOutOfMemoryError
    -
    -# Same as previous property, but allows to not repeat all other settings like -Xmx
    -#sonar.search.javaAdditionalOpts=
    -
    -# Elasticsearch port. Default is 9001. Use 0 to get a free port.
    -# As a security precaution, should be blocked by a firewall and not exposed to the Internet.
    -#sonar.search.port=9001
    -
    -# Elasticsearch host. The search server will bind this address and the search client will connect to it.
    -# Default is loopback address.
    -# As a security precaution, should NOT be set to a publicly available address.
    -#sonar.search.host=
    -
    -
     #--------------------------------------------------------------------------------------------------
     # UPDATE CENTER
     
    -# Update Center requires an internet connection to request https://update.sonarsource.org
    +# The Update Center requires an internet connection to request http://update.sonarsource.org
     # It is enabled by default.
    -#sonar.updatecenter.activate=true
    +sonar.updatecenter.activate=true
     
     # HTTP proxy (default none)
    -#http.proxyHost=
    -#http.proxyPort=
    -# HTTPS proxy (defaults are values of http.proxyHost and http.proxyPort)
    -#https.proxyHost=
    -#https.proxyPort=
    +http.proxyHost=
    +http.proxyPort=
     
     # NT domain name if NTLM proxy is used
    -#http.auth.ntlm.domain=
    +http.auth.ntlm.domain=
     
     # SOCKS proxy (default none)
    -#socksProxyHost=
    -#socksProxyPort=
    +socksProxyHost=
    +socksProxyPort=
     
    -# Proxy authentication (used for HTTP, HTTPS and SOCKS proxies)
    -#http.proxyUser=
    -#http.proxyPassword=
    +# proxy authentication. The 2 following properties are used for HTTP and SOCKS proxies.
    +http.proxyUser=
    +http.proxyPassword=
     
     
     #--------------------------------------------------------------------------------------------------
    -# LOGGING
    +# NOTIFICATIONS
     
    -# SonarQube produces logs in 4 logs files located in the same directory (see property sonar.path.logs below),
    -# one per process:
    -#   Main process (aka. App) logs in sonar.log
    -#   Web Server (aka. Web) logs in web.log
    -#   Compute Engine (aka. CE) logs in ce.log
    -#   Elasticsearch (aka. ES) logs in es.log
    -#
    -# All 4 files follow the same rolling policy (see sonar.log.rollingPolicy and sonar.log.maxFiles) but it applies
    -# individually (eg. if sonar.log.maxFiles=4, there can be at most 4 of each files, ie. 16 files in total).
    -#
    -# All 4 files have logs in the same format:
    -#           1           2    3           4                       5                                                   6
    -# |-----------------| |---| |-|--------------------||------------------------------| |------------------------------------------------------------------------------------------------------------------------------|
    -# 2016.11.16 16:47:00 INFO  ce[AVht0dNXFcyiYejytc3m][o.s.s.c.t.CeWorkerCallableImpl] Executed task | project=org.sonarqube:example-java-maven | type=REPORT | id=AVht0dNXFcyiYejytc3m | submitter=admin | time=1699ms
    -#
    -# 1: timestamp. Format is YYYY.MM.DD HH:MM:SS
    -#    YYYY: year on 4 digits
    -#    MM: month on 2 digits
    -#    DD: day on 2 digits
    -#    HH: hour of day on 2 digits in 24 hours format
    -#    MM: minutes on 2 digits
    -#    SS: seconds on 2 digits
    -# 2: log level.
    -#    Possible values (in order of descending criticality): ERROR, WARN, INFO, DEBUG and TRACE
    -# 3: process identifier. Possible values: app (main), web (Web Server), ce (Compute Engine) and es (Elasticsearch)
    -# 4: SQ thread identifier. Can be empty.
    -#    In the Web Server, if present, it will be the HTTP request ID.
    -#    In the Compute Engine, if present, it will be the task ID.
    -# 5: logger name. Usually a class canonical name.
    -#    Package names are truncated to keep the whole field to 20 characters max
    -# 6: log payload. Content of this field does not follow any specific format, can vary in length and include line returns.
    -#    Some logs, however, will follow the convention to provide data in payload in the format " | key=value"
    -#    Especially, log of profiled pieces of code will end with " | time=XXXXms".
    +# Delay (in seconds) between processing of notification queue
    +sonar.notifications.delay=60
     
    -# Global level of logs (applies to all 4 processes).
    -# Supported values are INFO (default), DEBUG and TRACE
    -#sonar.log.level=INFO
    -
    -# Level of logs of each process can be controlled individually with their respective properties.
    -# When specified, they overwrite the level defined at global level.
    -# Supported values are INFO, DEBUG and TRACE
    -#sonar.log.level.app=INFO
    -#sonar.log.level.web=INFO
    -#sonar.log.level.ce=INFO
    -#sonar.log.level.es=INFO
    -
    -# Path to log files. Can be absolute or relative to installation directory.
    -# Default is <installation home>/logs
    -#sonar.path.logs=logs
    -
    -# Rolling policy of log files
    -#    - based on time if value starts with "time:", for example by day ("time:yyyy-MM-dd")
    -#      or by month ("time:yyyy-MM")
    -#    - based on size if value starts with "size:", for example "size:10MB"
    -#    - disabled if value is "none".  That needs logs to be managed by an external system like logrotate.
    -#sonar.log.rollingPolicy=time:yyyy-MM-dd
    -
    -# Maximum number of files to keep if a rolling policy is enabled.
    -#    - maximum value is 20 on size rolling policy
    -#    - unlimited on time rolling policy. Set to zero to disable old file purging.
    -#sonar.log.maxFiles=7
    -
    -# Access log is the list of all the HTTP requests received by server. If enabled, it is stored
    -# in the file {sonar.path.logs}/access.log. This file follows the same rolling policy as other log file
    -# (see sonar.log.rollingPolicy and sonar.log.maxFiles).
    -#sonar.web.accessLogs.enable=true
    -
    -# Format of access log. It is ignored if sonar.web.accessLogs.enable=false. Possible values are:
    -#    - "common" is the Common Log Format, shortcut to: %h %l %u %user %date "%r" %s %b
    -#    - "combined" is another format widely recognized, shortcut to: %h %l %u [%t] "%r" %s %b "%i{Referer}" "%i{User-Agent}"
    -#    - else a custom pattern. See http://logback.qos.ch/manual/layouts.html#AccessPatternLayout.
    -# The login of authenticated user is not implemented with "%u" but with "%reqAttribute{LOGIN}" (since version 6.1).
    -# The value displayed for anonymous users is "-".
    -# The SonarQube's HTTP request ID can be added to the pattern with "%reqAttribute{ID}" (since version 6.2).
    -# If SonarQube is behind a reverse proxy, then the following value allows to display the correct remote IP address:
    -#sonar.web.accessLogs.pattern=%i{X-Forwarded-For} %l %u [%t] "%r" %s %b "%i{Referer}" "%i{User-Agent}" "%reqAttribute{ID}"
    -# Default value (which was "combined" before version 6.2) is equivalent to "combined + SQ HTTP request ID":
    -#sonar.web.accessLogs.pattern=%h %l %u [%t] "%r" %s %b "%i{Referer}" "%i{User-Agent}" "%reqAttribute{ID}"
    -
    -
     #--------------------------------------------------------------------------------------------------
    -# OTHERS
    +# PROFILING
    +# Level of information displayed in the logs: NONE (default), BASIC (functional information) and FULL (functional and technical details)
    +sonar.log.profilingLevel=NONE
     
    -# Delay in seconds between processing of notification queue. Default is 60 seconds.
    -#sonar.notifications.delay=60
     
    -# Paths to persistent data files (embedded database and search index) and temporary files.
    -# Can be absolute or relative to installation directory.
    -# Defaults are respectively <installation home>/data and <installation home>/temp
    -#sonar.path.data=data
    -#sonar.path.temp=temp
    -
    -# Telemetry - Share anonymous SonarQube statistics
    -# By sharing anonymous SonarQube statistics, you help us understand how SonarQube is used so we can improve the product to work even better for you.
    -# We don't collect source code or IP addresses. And we don't share the data with anyone else.
    -# To see an example of the data shared: login as a global administrator, call the WS api/system/info and check the Statistics field.
    -#sonar.telemetry.enable=true
    -
    -
     #--------------------------------------------------------------------------------------------------
    -# DEVELOPMENT - only for developers
    -# The following properties MUST NOT be used in production environments.
    +# DEVELOPMENT MODE
    +# Only for debugging
     
    -# Elasticsearch HTTP connector
    -#sonar.search.httpPort=-1
    +# Set to true to apply Ruby on Rails code changes on the fly
    +sonar.rails.dev=false
    +
    - change mode from '0644' to '0600'
    - restore selinux security context
  * link[/usr/bin/sonarqube] action create
    - create symlink at /usr/bin/sonarqube to /opt/sonarqube-7.0/bin/linux-x86-64/sonar.sh
  * template[/etc/init.d/sonarqube] action create
    - create new file /etc/init.d/sonarqube
    - update content in file /etc/init.d/sonarqube from none to 650af0
    --- /etc/init.d/sonarqube	2018-02-26 10:51:07.469217845 +0000
    +++ /etc/init.d/.chef-sonarqube20180226-8280-4fxivy	2018-02-26 10:51:07.468217872 +0000
    @@ -1 +1,20 @@
    +#!/bin/sh
    +#
    +# rc file for SonarQube
    +#
    +# chkconfig: 345 96 10
    +# description: SonarQube system (www.sonarsource.org)
    +#
    +### BEGIN INIT INFO
    +# Provides: sonar
    +# Required-Start: $network
    +# Required-Stop: $network
    +# Default-Start: 3 4 5
    +# Default-Stop: 0 1 2 6
    +# Short-Description: SonarQube system (www.sonarsource.org)
    +# Description: SonarQube system (www.sonarsource.org)
    +### END INIT INFO
    + 
    +export RUN_AS_USER=sonarqube
    +/usr/bin/sonarqube $*
    - change mode from '' to '0755'
    - change owner from '' to 'root'
    - change group from '' to 'root'
    - restore selinux security context
  * service[sonarqube] action enable
    - enable service service[sonarqube]
  * service[sonarqube] action start
    - start service service[sonarqube]
Recipe: <Dynamically Defined Resource>
  * linux_user[chefautomate] action create
    - create user chefautomate
  * directory[/var/opt/chef/bin] action create
    - create new directory /var/opt/chef/bin
    - restore selinux security context
  * directory[/var/opt/chef/etc] action create
    - create new directory /var/opt/chef/etc
    - restore selinux security context
  * directory[/var/log/chef/automate-liveness-agent] action create
    - create new directory /var/log/chef/automate-liveness-agent
    - change owner from '' to 'chefautomate'
    - restore selinux security context
  * file[/var/opt/chef/bin/automate-liveness-agent] action create
    - create new file /var/opt/chef/bin/automate-liveness-agent
    - update content in file /var/opt/chef/bin/automate-liveness-agent from none to d7ad5d
    --- /var/opt/chef/bin/automate-liveness-agent	2018-02-26 10:51:08.757183759 +0000
    +++ /var/opt/chef/bin/.chef-automate-liveness-agent20180226-8280-juss5t	2018-02-26 10:51:08.757183759 +0000
    @@ -1 +1,788 @@
    +#!/opt/chef/embedded/bin/ruby
    +# Compiled at 2017-06-21 11:52:07 -0700
    +## lib/automate_liveness_agent/vendor/mixlib-authentication/lib/mixlib/authentication/null_logger.rb ##
    +module Mixlib
    +  module Authentication
    +    module NullLogger
    +      attr_accessor :level
    +      %i{debug info warn error fatal}.each do |method_name|
    +        class_eval(<<-METHOD_DEFN, __FILE__, __LINE__)
    +          def #{method_name}(msg=nil, &block)
    +            true
    +          end
    +        METHOD_DEFN
    +      end
    +      %i{debug? info? warn? error? fatal?}.each do |method_name|
    +        class_eval(<<-METHOD_DEFN, __FILE__, __LINE__)
    +          def #{method_name}
    +            false
    +          end
    +        METHOD_DEFN
    +      end
    +    end
    +  end
    +end
    +## lib/automate_liveness_agent/vendor/mixlib-authentication/lib/mixlib/authentication.rb ##
    +module Mixlib
    +  module Authentication
    +    DEFAULT_SERVER_API_VERSION = "0"
    +    attr_accessor :logger
    +    module_function :logger, :logger=
    +    class AuthenticationError < StandardError
    +    end
    +    class MissingAuthenticationHeader < AuthenticationError
    +    end
    +    class Log
    +    end
    +    Mixlib::Authentication::Log.extend(Mixlib::Authentication::NullLogger)
    +    Mixlib::Authentication.logger = Mixlib::Authentication::Log
    +    Mixlib::Authentication.logger.level = :error
    +  end
    +end
    +## lib/automate_liveness_agent/vendor/mixlib-authentication/lib/mixlib/authentication/digester.rb ##
    +require "openssl"
    +module Mixlib
    +  module Authentication
    +    class Digester
    +      class << self
    +        def hash_file(f, digest = OpenSSL::Digest::SHA1)
    +          digester = digest.new
    +          buf = ""
    +          digester.update buf while f.read(16384, buf)
    +          ::Base64.encode64(digester.digest).chomp
    +        end
    +        def hash_string(str, digest = OpenSSL::Digest::SHA1)
    +          ::Base64.encode64(digest.digest(str)).chomp
    +        end
    +      end
    +    end
    +  end
    +end
    +## lib/automate_liveness_agent/vendor/mixlib-authentication/lib/mixlib/authentication/signedheaderauth.rb ##
    +require "time"
    +require "base64"
    +require "openssl/digest"
    +module Mixlib
    +  module Authentication
    +    module SignedHeaderAuth
    +      NULL_ARG = Object.new
    +      ALGORITHM_FOR_VERSION = {
    +        "1.0" => "sha1",
    +        "1.1" => "sha1",
    +        "1.3" => "sha256",
    +      }.freeze()
    +      SUPPORTED_ALGORITHMS = ["sha1"].freeze
    +      SUPPORTED_VERSIONS = ["1.0", "1.1"].freeze
    +      DEFAULT_SIGN_ALGORITHM = "sha1".freeze
    +      DEFAULT_PROTO_VERSION = "1.0".freeze
    +      def self.signing_object(args = {})
    +        SigningObject.new(args[:http_method],
    +                          args[:path],
    +                          args[:body],
    +                          args[:host],
    +                          args[:timestamp],
    +                          args[:user_id],
    +                          args[:file],
    +                          args[:proto_version],
    +                          args[:headers]
    +                         )
    +      end
    +      def algorithm
    +        ALGORITHM_FOR_VERSION[proto_version] || DEFAULT_SIGN_ALGORITHM
    +      end
    +      def proto_version
    +        DEFAULT_PROTO_VERSION
    +      end
    +      def sign(private_key, sign_algorithm = algorithm, sign_version = proto_version)
    +        digest = validate_sign_version_digest!(sign_algorithm, sign_version)
    +        header_hash = {
    +          "X-Ops-Sign" => "algorithm=#{sign_algorithm};version=#{sign_version};",
    +          "X-Ops-Userid" => user_id,
    +          "X-Ops-Timestamp" => canonical_time,
    +          "X-Ops-Content-Hash" => hashed_body(digest),
    +        }
    +        signature = Base64.encode64(do_sign(private_key, digest, sign_algorithm, sign_version)).chomp
    +        signature_lines = signature.split(/\n/)
    +        signature_lines.each_index do |idx|
    +          key = "X-Ops-Authorization-#{idx + 1}"
    +          header_hash[key] = signature_lines[idx]
    +        end
    +        Mixlib::Authentication.logger.debug "Header hash: #{header_hash.inspect}"
    +        header_hash
    +      end
    +      def validate_sign_version_digest!(sign_algorithm, sign_version)
    +        if ALGORITHM_FOR_VERSION[sign_version].nil?
    +          raise AuthenticationError,
    +            "Unsupported version '#{sign_version}'"
    +        end
    +        if ALGORITHM_FOR_VERSION[sign_version] != sign_algorithm
    +          raise AuthenticationError,
    +            "Unsupported algorithm #{sign_algorithm} for version '#{sign_version}'"
    +        end
    +        case sign_algorithm
    +        when "sha1"
    +          OpenSSL::Digest::SHA1
    +        when "sha256"
    +          OpenSSL::Digest::SHA256
    +        else
    +          raise "Unknown algorithm #{sign_algorithm}"
    +        end
    +      end
    +      def canonical_time
    +        Time.parse(timestamp).utc.iso8601
    +      end
    +      def canonical_path
    +        p = path.gsub(/\/+/, "/")
    +        p.length > 1 ? p.chomp("/") : p
    +      end
    +      def hashed_body(digest = OpenSSL::Digest::SHA1)
    +        @hashed_body_digest = nil unless defined?(@hashed_body_digest)
    +        if !@hashed_body_digest.nil? && @hashed_body_digest != digest
    +          raise "hashed_body must always be called with the same digest"
    +        else
    +          @hashed_body_digest = digest
    +        end
    +        @hashed_body ||= if self.file && self.file.respond_to?(:read)
    +                           digester.hash_file(self.file, digest)
    +                         else
    +                           digester.hash_string(self.body, digest)
    +                         end
    +      end
    +      def canonicalize_request(sign_algorithm = algorithm, sign_version = proto_version)
    +        digest = validate_sign_version_digest!(sign_algorithm, sign_version)
    +        canonical_x_ops_user_id = canonicalize_user_id(user_id, sign_version, digest)
    +        case sign_version
    +        when "1.3"
    +          [
    +            "Method:#{http_method.to_s.upcase}",
    +            "Path:#{canonical_path}",
    +            "X-Ops-Content-Hash:#{hashed_body(digest)}",
    +            "X-Ops-Sign:version=#{sign_version}",
    +            "X-Ops-Timestamp:#{canonical_time}",
    +            "X-Ops-UserId:#{canonical_x_ops_user_id}",
    +            "X-Ops-Server-API-Version:#{server_api_version}",
    +          ].join("\n")
    +        else
    +          [
    +            "Method:#{http_method.to_s.upcase}",
    +            "Hashed Path:#{digester.hash_string(canonical_path, digest)}",
    +            "X-Ops-Content-Hash:#{hashed_body(digest)}",
    +            "X-Ops-Timestamp:#{canonical_time}",
    +            "X-Ops-UserId:#{canonical_x_ops_user_id}",
    +          ].join("\n")
    +        end
    +      end
    +      def canonicalize_user_id(user_id, proto_version, digest = OpenSSL::Digest::SHA1)
    +        case proto_version
    +        when "1.1"
    +          digester.hash_string(user_id, digest)
    +        else
    +          user_id
    +        end
    +      end
    +      def parse_signing_description
    +        parts = signing_description.strip.split(";").inject({}) do |memo, part|
    +          field_name, field_value = part.split("=")
    +          memo[field_name.to_sym] = field_value.strip
    +          memo
    +        end
    +        Mixlib::Authentication.logger.debug "Parsed signing description: #{parts.inspect}"
    +        parts
    +      end
    +      def digester
    +        Mixlib::Authentication::Digester
    +      end
    +      def do_sign(private_key, digest, sign_algorithm, sign_version)
    +        string_to_sign = canonicalize_request(sign_algorithm, sign_version)
    +        Mixlib::Authentication.logger.debug "String to sign: '#{string_to_sign}'"
    +        case sign_version
    +        when "1.3"
    +          private_key.sign(digest.new, string_to_sign)
    +        else
    +          private_key.private_encrypt(string_to_sign)
    +        end
    +      end
    +      private :canonical_time, :canonical_path, :parse_signing_description, :digester, :canonicalize_user_id
    +    end
    +    SigningObject = Struct.new(:http_method, :path, :body, :host,
    +                                     :timestamp, :user_id, :file, :proto_version,
    +                                     :headers) do
    +      include SignedHeaderAuth
    +      def proto_version
    +        (self[:proto_version] || SignedHeaderAuth::DEFAULT_PROTO_VERSION).to_s
    +      end
    +      def server_api_version
    +        key = (self[:headers] || {}).keys.select do |k|
    +          k.casecmp("x-ops-server-api-version") == 0
    +        end.first
    +        if key
    +          self[:headers][key]
    +        else
    +          DEFAULT_SERVER_API_VERSION
    +        end
    +      end
    +    end
    +  end
    +end
    +## lib/automate_liveness_agent/version.rb ##
    +module AutomateLivenessAgent
    +  VERSION = "0.7.1"
    +end
    +## lib/automate_liveness_agent/config.rb ##
    +require "json"
    +require "logger"
    +module AutomateLivenessAgent
    +  class ConfigError < StandardError
    +  end
    +  class Config
    +    DEFAULT_CONFIG_PATH = "/etc/chef/config.json"
    +    DEFAULT_VERIFY_MODE = "verify_peer"
    +    STDOUT_STRING = "STDOUT"
    +    STDERR_STRING = "STDERR"
    +    SIZE_512K = 1024 * 512
    +    SIZE_2K   = 1024 * 2
    +    LOGGER_STRESS_MODE = "LOGGER_STRESS_MODE"
    +    MANDATORY_CONFIG_SETTINGS = %w{
    +      chef_server_fqdn
    +      client_key_path
    +      client_name
    +      data_collector_url
    +      entity_uuid
    +      org_name
    +      unprivileged_uid
    +      unprivileged_gid
    +    }.freeze
    +    attr_reader :config_path
    +    attr_reader :chef_server_fqdn
    +    attr_reader :client_key
    +    attr_reader :client_key_path
    +    attr_reader :client_key
    +    attr_reader :client_name
    +    attr_reader :daemon_mode
    +    attr_reader :data_collector_url
    +    attr_reader :entity_uuid
    +    attr_reader :org_name
    +    attr_reader :ssl_verify_mode
    +    attr_reader :ssl_ca_file
    +    attr_reader :ssl_ca_path
    +    attr_reader :trusted_certs_dir
    +    attr_reader :unprivileged_uid
    +    attr_reader :unprivileged_gid
    +    attr_reader :install_check_file
    +    attr_reader :log_file
    +    attr_reader :scheduled_task_mode
    +    def self.load(config_path)
    +      c = new(config_path)
    +      c.load
    +      c
    +    end
    +    def initialize(config_path)
    +      @config_path  = File.expand_path(config_path || DEFAULT_CONFIG_PATH, Dir.pwd)
    +      @logger       = nil
    +      @chef_server_fqdn     = nil
    +      @client_key           = nil
    +      @client_key_path      = nil
    +      @client_name          = nil
    +      @daemon_mode          = nil
    +      @data_collector_url   = nil
    +      @entity_uuid          = nil
    +      @org_name             = nil
    +      @ssl_verify_mode      = DEFAULT_VERIFY_MODE
    +      @ssl_ca_file          = nil
    +      @ssl_ca_path          = nil
    +      @trusted_certs_dir    = nil
    +      @unprivileged_uid     = nil
    +      @unprivileged_gid     = nil
    +      @install_check_file   = nil
    +      @log_file             = nil
    +      @scheduled_task_mode  = false
    +    end
    +    def load
    +      load_config_file
    +      load_client_key
    +    end
    +    def load_data(config_data)
    +      apply_config_values(config_data)
    +      load_client_key
    +      self
    +    end
    +    def load_config_file
    +      sanity_check_config_path
    +      config_data = parse_config_file
    +      apply_config_values(config_data)
    +    end
    +    def setup_logger
    +      @logger ||= Logger.new(validate_and_normalize_log_path(log_file), 1, logfile_max_size)
    +    end
    +    def load_client_key
    +      if !(File.exist?(client_key_path) && File.readable?(client_key_path))
    +        raise ConfigError,
    +          "Configured client_key_path '#{client_key_path}' does not exist or is not readable (current uid: #{Process.uid})"
    +      end
    +      @client_key = File.read(client_key_path)
    +    end
    +    def apply_config_values(config_data)
    +      missing_settings = MANDATORY_CONFIG_SETTINGS - config_data.keys
    +      unless missing_settings.empty?
    +        raise ConfigError, "Config file '#{config_path}' is missing mandatory setting(s): \"#{missing_settings.join('","')}\""
    +      end
    +      @chef_server_fqdn   = config_data["chef_server_fqdn"]
    +      @client_key_path    = config_data["client_key_path"]
    +      @client_name        = config_data["client_name"]
    +      @data_collector_url = config_data["data_collector_url"]
    +      @entity_uuid        = config_data["entity_uuid"]
    +      @org_name           = config_data["org_name"]
    +      @unprivileged_uid   = config_data["unprivileged_uid"]
    +      @unprivileged_gid   = config_data["unprivileged_gid"]
    +      if config_data.key?("ssl_verify_mode") && !!config_data["ssl_verify_mode"]
    +        sanity_check_ssl_verify_mode(config_data["ssl_verify_mode"])
    +      end
    +      if config_data.key?("ssl_ca_file") && !!config_data["ssl_ca_file"]
    +        sanity_check_ssl_ca_file(config_data["ssl_ca_file"])
    +      end
    +      if config_data.key?("ssl_ca_path") && !!config_data["ssl_ca_path"]
    +        sanity_check_ssl_ca_path(config_data["ssl_ca_path"])
    +      end
    +      if config_data.key?("trusted_certs_dir") && !!config_data["trusted_certs_dir"]
    +        sanity_check_trusted_certs_dir(config_data["trusted_certs_dir"])
    +      end
    +      if config_data.key?("daemon_mode")
    +        sanity_check_daemon_mode(config_data["daemon_mode"])
    +      end
    +      @install_check_file   = config_data["install_check_file"]
    +      @log_file             = config_data["log_file"]
    +      @scheduled_task_mode  = config_data["scheduled_task_mode"]
    +      self
    +    end
    +    private
    +    def sanity_check_ssl_verify_mode(verify_mode)
    +      if verify_mode =~ /^verify_(peer|none)$/
    +        @ssl_verify_mode = verify_mode
    +      else
    +        raise(
    +          ConfigError,
    +          "'#{verify_mode}' is not a valid ssl_verify_mode."\
    +          " Valid options are 'verify_peer' and 'verify_none'."
    +        )
    +      end
    +    end
    +    def sanity_check_ssl_ca_path(ca_path)
    +      if File.directory?(ca_path)
    +        @ssl_ca_path = ca_path
    +      else
    +        raise ConfigError, "ssl_ca_path '#{ca_path}' is not a directory"
    +      end
    +    end
    +    def sanity_check_ssl_ca_file(ca_file)
    +      if File.exist?(ca_file)
    +        @ssl_ca_file = ca_file
    +      else
    +        raise ConfigError, "ssl_ca_file '#{ca_file}' does not exist"
    +      end
    +    end
    +    def sanity_check_trusted_certs_dir(dir)
    +      if File.directory?(dir)
    +        @trusted_certs_dir = dir
    +      else
    +        raise ConfigError, "trusted_certs_dir '#{dir}' is not a directory"
    +      end
    +    end
    +    def parse_config_file
    +      JSON.parse(File.read(config_path))
    +    rescue JSON::ParserError
    +      raise ConfigError, "Config file '#{config_path}' has a JSON formatting error"
    +    end
    +    def sanity_check_config_path
    +      if !File.exist?(config_path)
    +        raise ConfigError, "Config file '#{config_path}' does not exist or is not readable"
    +      end
    +      if !File.readable?(config_path)
    +        raise ConfigError, "Config file '#{config_path}' is not readable (current uid = #{Process.euid})"
    +      end
    +      if File.size(config_path) == 0
    +        raise ConfigError, "Config file '#{config_path}' is empty"
    +      end
    +    end
    +    def sanity_check_daemon_mode(mode)
    +      @daemon_mode = mode.is_a?(TrueClass) || mode == "true" ? true : false
    +    end
    +    def validate_and_normalize_log_path(log_path)
    +      case log_path
    +      when STDOUT_STRING, nil
    +        STDOUT
    +      when STDERR_STRING
    +        STDERR
    +      else
    +        validate_log_path(log_path)
    +        log_path
    +      end
    +    end
    +    def validate_log_path(log_path)
    +      log_dir = File.dirname(log_path)
    +      unless File.directory?(log_dir)
    +        raise ConfigError, "Log directory '#{log_dir}' (inferred from log_path config) does not exist or is not a directory"
    +      end
    +      unless File.writable?(log_dir)
    +        raise ConfigError, "Log directory '#{log_dir}' (inferred from log_path config) is not writable by current user (uid: #{Process.uid})"
    +      end
    +      if File.exist?(log_path) && !File.writable?(log_path)
    +        raise ConfigError, "Log file '#{log_file}' (set by log_path config) is not writable by current user (uid: #{Process.uid})"
    +      end
    +      log_path
    +    end
    +    def logfile_max_size
    +      if ENV[LOGGER_STRESS_MODE]
    +        SIZE_2K
    +      else
    +        SIZE_512K
    +      end
    +    end
    +  end
    +end
    +## lib/automate_liveness_agent/api_client.rb ##
    +require "openssl"
    +require "net/http"
    +require "uri"
    +module AutomateLivenessAgent
    +  class APIClient
    +    MIXLIB_AUTHN_PROTO_VERSION = "1.3"
    +    APPLICATION_JSON = "application/json"
    +    HTTP_METHOD = "POST"
    +    VALID_PROTOCOLS = %w{ http https }.freeze
    +    BASE_HEADERS = {
    +      "Accept" => APPLICATION_JSON,
    +      "X-Chef-Version" => "13.0.0",
    +      "User-Agent" => "Automate Liveness Agent #{AutomateLivenessAgent::VERSION}",
    +      "Content-Type" => APPLICATION_JSON,
    +    }.freeze
    +    DEBUG = "DEBUG"
    +    RETRY_LIMIT = 5
    +    ERROR = "Error"
    +    SUCCESS = "Success"
    +    HTTPS_SCHEME = "https"
    +    attr_reader :config
    +    attr_reader :logger
    +    attr_reader :uri
    +    attr_reader :base_request_params
    +    attr_reader :private_key
    +    attr_reader :http
    +    def initialize(config, logger)
    +      @config = config
    +      @logger = logger
    +    end
    +    def load_and_verify_config
    +      parse_key
    +      parse_uri
    +      set_base_request_params
    +      setup_http_client
    +      self
    +    end
    +    def request(body)
    +      retry_count ||= -1
    +      retry_count += 1
    +      request_without_retries(body)
    +    rescue Net::HTTPError, Net::HTTPRetriableError, Net::HTTPServerException, Net::HTTPFatalError => e
    +      error_response = e.response
    +      log_response(ERROR, error_response)
    +      retry if wait_for_retry_or_give_up(retry_count)
    +    rescue SocketError, Errno::ETIMEDOUT, Errno::ECONNRESET => e
    +      log("Error initiating connection to #{uri.host}:#{uri.port} - #{e}")
    +      retry if wait_for_retry_or_give_up(retry_count)
    +    rescue Errno::ECONNREFUSED => e
    +      log("Connection refused for #{uri.host}:#{uri.port} - #{e}")
    +      retry if wait_for_retry_or_give_up(retry_count)
    +    rescue Timeout::Error => e
    +      log("Timeout connecting to #{uri.host}:#{uri.port} - #{e}")
    +      retry if wait_for_retry_or_give_up(retry_count)
    +    rescue OpenSSL::SSL::SSLError => e
    +      log("SSL error connecting to #{uri.host}:#{uri.port} - #{e}")
    +      retry if wait_for_retry_or_give_up(retry_count)
    +    end
    +    def setup_request(body)
    +      Net::HTTP::Post.new(uri, headers_for(body)).tap do |req|
    +        req.content_type = APPLICATION_JSON
    +        req.body = body
    +      end
    +    end
    +    def headers_for(body)
    +      BASE_HEADERS.merge(signature_headers(body))
    +    end
    +    private
    +    def log(message)
    +      logger.info(message)
    +    end
    +    def request_without_retries(body)
    +      req = setup_request(body)
    +      res = send_request(req)
    +      res.value
    +      log_response(SUCCESS, res)
    +    end
    +    def log_response(status, response)
    +      log("HTTP Request to #{uri} finished (#{status}): #{response.code} #{response.message}")
    +      log("Response body: #{response.body}")
    +    end
    +    def wait_for_retry_or_give_up(retry_count)
    +      if retry_count >= RETRY_LIMIT
    +        log("Retry limit exceeded, giving up")
    +        return false
    +      end
    +      sleep_time = 1 + (2**retry_count) + rand(2**retry_count)
    +      log("Waiting #{sleep_time}s for retry")
    +      sleep(sleep_time)
    +      true
    +    end
    +    def send_request(req)
    +      if ENV[DEBUG]
    +        puts "Request Data ".ljust(80, "=")
    +        JSON.parse(req.body) # will fail if req body is malformed
    +        print "req:       #{req.inspect}\n"
    +        print "uri:       #{uri}\n"
    +        print "hostname:  #{uri.hostname}\n"
    +        print "port:      #{uri.port}\n"
    +        print "headers:\n"
    +        req.to_hash.keys.sort.each do |h_key|
    +          print "  #{h_key}: #{req[h_key]}\n"
    +        end
    +        puts "End Request Data ".ljust(80, "=")
    +        http.set_debug_output($stderr)
    +      end
    +      http.start do |connection|
    +        connection.request(req)
    +      end
    +    ensure
    +      http.set_debug_output(nil)
    +    end
    +    def signature_headers(body)
    +      request_params = base_request_params.merge(body: body, timestamp: Time.now.utc.iso8601)
    +      sign_obj = Mixlib::Authentication::SignedHeaderAuth.signing_object(request_params)
    +      signed = sign_obj.sign(private_key)
    +      signed.inject({}) { |memo, kv| memo["#{kv[0].to_s.upcase}"] = kv[1]; memo }
    +    end
    +    def parse_key
    +      @private_key = OpenSSL::PKey::RSA.new(config.client_key)
    +    rescue OpenSSL::PKey::RSAError => e
    +      raise ConfigError, "Private key '#{config.client_key_path}' is malformed (#{e})"
    +    end
    +    def parse_uri
    +      @uri = URI(config.data_collector_url)
    +      unless VALID_PROTOCOLS.include?(uri.scheme)
    +        raise ConfigError, "Data Collector URL '#{config.data_collector_url}' is invalid: only 'http' and 'https' protocols are supported"
    +      end
    +      @uri
    +    rescue URI::InvalidURIError => e
    +      raise ConfigError, "Data Collector URL '#{config.data_collector_url}' is malformed (#{e})"
    +    end
    +    def set_base_request_params
    +      @base_request_params = {
    +        http_method: HTTP_METHOD,
    +        path: uri.path,
    +        host: "#{uri.host}:#{uri.port}",
    +        headers: BASE_HEADERS,
    +        user_id: config.client_name,
    +        proto_version: MIXLIB_AUTHN_PROTO_VERSION,
    +      }
    +    end
    +    def setup_http_client
    +      @http = Net::HTTP.new(uri.hostname, uri.port).tap do |h|
    +        h.open_timeout = 10
    +        h.read_timeout = 10
    +        h.ssl_timeout  = 10
    +        h.use_ssl      = uri.scheme == HTTPS_SCHEME
    +        h.verify_mode  = OpenSSL::SSL.const_get(config.ssl_verify_mode.upcase)
    +        h.ca_path      = config.ssl_ca_path if config.ssl_ca_path
    +        h.ca_file      = config.ssl_ca_file if config.ssl_ca_file
    +        h.cert_store   = OpenSSL::X509::Store.new
    +        h.cert_store.set_default_paths
    +        if !config.trusted_certs_dir.nil? && File.directory?(config.trusted_certs_dir)
    +          Dir.glob(File.join(config.trusted_certs_dir, "*.{crt,pem}")).each do |crt|
    +            begin
    +              h.cert_store.add_cert(OpenSSL::X509::Certificate.new(File.read(crt)))
    +            rescue OpenSSL::X509::StoreError => e
    +              print e.message if ENV[DEBUG]
    +            end
    +          end
    +        end
    +      end
    +    end
    +  end
    +end
    +## lib/automate_liveness_agent/liveness_update_sender.rb ##
    +require "time"
    +module AutomateLivenessAgent
    +  class LivenessUpdateSender
    +    attr_reader :config
    +    attr_reader :logger
    +    attr_reader :api_client
    +    UPDATE_INTERVAL_S = 60 * 30
    +    def initialize(config, logger)
    +      @config = config
    +      @logger = logger
    +      @api_client = APIClient.new(config, logger)
    +      api_client.load_and_verify_config
    +    end
    +    def log(message)
    +      logger.info(message)
    +    end
    +    def main_loop
    +      obj_counts = {}
    +      log("PROCESS ID: #{Process.pid}")
    +      interval = (ENV["INTERVAL"] || UPDATE_INTERVAL_S).to_i
    +      loop do
    +        if chef_uninstalled?
    +          log("Chef Client appears to have been uninstalled, shutting down")
    +          break false
    +        end
    +        now = Time.now.to_i
    +        next_run = now + interval
    +        update
    +        GC.start
    +        ObjectSpace.count_objects(obj_counts)
    +        log("Total ruby objects: #{obj_counts[:TOTAL]}; Free heap slots: #{obj_counts[:FREE]}")
    +        sleep_time = [ next_run - Time.now.to_i, 0 ].max
    +        log("Waiting #{sleep_time}s until next update")
    +        sleep(sleep_time)
    +      end
    +    rescue Interrupt, SystemExit => e
    +      log("Signal received (#{e.inspect}), exiting")
    +      return true
    +    end
    +    def update
    +      api_client.request(update_payload)
    +    end
    +    def base_payload
    +      @base_payload ||= {
    +        "chef_server_fqdn" => config.chef_server_fqdn,
    +        "source" => "liveness_agent",
    +        "message_version" => "0.0.1",
    +        "event_type" => "node_ping",
    +        "organization_name" => config.org_name,
    +        "node_name" => config.client_name,
    +        "entity_uuid" => config.entity_uuid,
    +      }.freeze
    +    end
    +    def update_payload
    +      base_payload.merge("@timestamp" => Time.now.utc.iso8601).to_json
    +    end
    +    def chef_uninstalled?
    +      return false if config.install_check_file.nil?
    +      !File.exist?(config.install_check_file)
    +    end
    +  end
    +end
    +## lib/automate_liveness_agent/main.rb ##
    +module AutomateLivenessAgent
    +  class Pipeline
    +    def initialize(implementation)
    +      @implementation = implementation
    +      @exit_code = 0
    +      @message = ""
    +    end
    +    def run(method_name)
    +      if @exit_code == 0
    +        @exit_code, @message = @implementation.public_send(method_name)
    +      end
    +      self
    +    end
    +    def finish
    +      if @exit_code != 0
    +        $stderr.print("#{@message}\n")
    +      end
    +      Kernel.exit(@exit_code)
    +    end
    +  end
    +  class Main
    +    USAGE = "Usage: automate-liveness-agent [config_file]"
    +    SUCCESS = [ 0, "" ].freeze
    +    PIDFILE_LOCATION = "/var/run/automate-liveness-agent.pid"
    +    WRITE_MODE = "w"
    +    attr_reader :argv
    +    attr_reader :config_path
    +    attr_reader :config
    +    attr_reader :logger
    +    def self.run(argv)
    +      new(argv).run
    +    end
    +    def initialize(argv)
    +      @argv = argv
    +      @config_path = nil
    +      @config = Config.new(nil)
    +      @logger = nil
    +      @pidfile_handle = nil
    +    end
    +    def run
    +      Pipeline.new(self).
    +        run(:handle_argv).
    +        run(:load_config).
    +        run(:set_privileges).
    +        run(:setup_logger).
    +        run(:send_keepalives).
    +        finish
    +    end
    +    def handle_argv
    +      case argv.size
    +      when 0
    +        SUCCESS
    +      when 1
    +        if %w{ -h --help help }.include?(argv[0])
    +          [1, USAGE]
    +        else
    +          @config_path = argv[0]
    +          SUCCESS
    +        end
    +      else
    +        [1, USAGE]
    +      end
    +    end
    +    def load_config
    +      @config = Config.load(config_path)
    +      SUCCESS
    +    rescue ConfigError => e
    +      [ 1, e.to_s ]
    +    end
    +    def set_privileges
    +      unless config.scheduled_task_mode
    +        @pidfile_handle = File.open(PIDFILE_LOCATION, WRITE_MODE, 0644)
    +      end
    +      unless config.unprivileged_gid.nil?
    +        Process::Sys.setgid(config.unprivileged_gid)
    +      end
    +      unless config.unprivileged_uid.nil?
    +        Process::Sys.setuid(config.unprivileged_uid)
    +      end
    +      SUCCESS
    +    rescue Errno::EACCES
    +      msg = "Unable to open pidfile at #{PIDFILE_LOCATION} (current uid: #{Process.uid})"
    +      [ 1, msg ]
    +    rescue Errno::EPERM
    +      msg = "You must run as root to change privileges, or you can set unprivileged_uid and unprivileged_gid to null to disable privilege changes"
    +      [ 1, msg ]
    +    end
    +    def setup_logger
    +      @logger = config.setup_logger
    +      SUCCESS
    +    rescue ConfigError => e
    +      [ 1, e.to_s ]
    +    end
    +    def send_keepalives
    +      a = LivenessUpdateSender.new(config, logger)
    +      if config.scheduled_task_mode
    +        a.update
    +      else
    +        Process.daemon if config.daemon_mode
    +        if @pidfile_handle
    +          @pidfile_handle.write(Process.pid)
    +          @pidfile_handle.close
    +        end
    +        a.main_loop
    +      end
    +      SUCCESS
    +    rescue ConfigError => e
    +      [ 1, e.to_s ]
    +    end
    +  end
    +end
    +## bin/automate-liveness-agent ##
    +$LOAD_PATH.unshift(File.expand_path("../../lib", __FILE__))
    +AutomateLivenessAgent::Main.run(ARGV) unless ENV["AUTOMATE_LIVENESS_AGENT_SPECS_MODE"]
    +
    - change mode from '' to '0755'
    - change owner from '' to 'root'
    - change group from '' to 'root'
    - restore selinux security context
  * file[/var/opt/chef/etc/config.json] action create
    - create new file /var/opt/chef/etc/config.json
    - update content in file /var/opt/chef/etc/config.json from none to 68f7e8
    --- /var/opt/chef/etc/config.json	2018-02-26 10:51:08.906179816 +0000
    +++ /var/opt/chef/etc/.chef-config20180226-8280-1ag69hd.json	2018-02-26 10:51:08.906179816 +0000
    @@ -1 +1,19 @@
    +{
    +  "chef_server_fqdn": "prod-chef-esgelcsrwlcxujxx.us-east-1.opsworks-cm.io",
    +  "client_key_path": "/etc/chef/client.pem",
    +  "client_name": "i-0155558fc7d449996",
    +  "daemon_mode": true,
    +  "data_collector_url": "https://prod-chef-esgelcsrwlcxujxx.us-east-1.opsworks-cm.io/organizations/default/data-collector",
    +  "entity_uuid": "0c057b83-dcb8-48cf-bf1a-da2a7fc357e8",
    +  "install_check_file": "/opt/chef/embedded/bin/ruby",
    +  "org_name": "default",
    +  "unprivileged_uid": 1001,
    +  "unprivileged_gid": 1001,
    +  "log_file": "/var/log/chef/automate-liveness-agent/automate-liveness-agent.log",
    +  "ssl_verify_mode": "verify_peer",
    +  "ssl_ca_file": null,
    +  "ssl_ca_path": null,
    +  "trusted_certs_dir": "/etc/chef/trusted_certs",
    +  "scheduled_task_mode": false
    +}
    - change mode from '' to '0755'
    - change owner from '' to 'root'
    - change group from '' to 'root'
    - restore selinux security context
  * file[/etc/init.d/automate-liveness-agent] action create
    - create new file /etc/init.d/automate-liveness-agent
    - update content in file /etc/init.d/automate-liveness-agent from none to 8a39aa
    --- /etc/init.d/automate-liveness-agent	2018-02-26 10:51:08.999177355 +0000
    +++ /etc/init.d/.chef-automate-liveness-agent20180226-8280-15g4amh	2018-02-26 10:51:08.999177355 +0000
    @@ -1 +1,65 @@
    +#!/bin/sh
    +### BEGIN INIT INFO
    +# Provides:          automate-liveness-agent
    +# Required-Start:    $local_fs $network $named $time $syslog
    +# Required-Stop:     $local_fs $network $named $time $syslog
    +# Default-Start:     2 3 4 5
    +# Default-Stop:      0 1 6
    +# Short-Description: Start the automate-liveness-agent at boot
    +# Description:       Start the automate-liveness-agent at boot
    +### END INIT INFO
    +
    +SCRIPT="RUBYOPT='--disable-gems' RUBY_GC_HEAP_GROWTH_MAX_SLOTS=500 /var/opt/chef/bin/automate-liveness-agent /var/opt/chef/etc/config.json"
    +RUNAS=root
    +
    +PIDFILE=/var/run/automate-liveness-agent.pid
    +
    +start() {
    +  if [ -f "$PIDFILE" ] && kill -0 $(cat "$PIDFILE"); then
    +    echo 'Service already running' >&2
    +    return 0
    +  fi
    +  echo 'Starting service' >&2
    +  su -c "$SCRIPT" $RUNAS
    +  echo 'Service started' >&2
    +}
    +
    +stop() {
    +  if [ ! -f "$PIDFILE" ] || ! kill -0 $(cat "$PIDFILE"); then
    +    echo 'Service not running' >&2
    +    return 0
    +  fi
    +  echo 'Stopping service' >&2
    +  kill -15 $(cat "$PIDFILE")
    +  rm -f "$PIDFILE"
    +  echo 'Service stopped' >&2
    +}
    +
    +status() {
    +  if [ -f "$PIDFILE" ] && kill -0 $(cat "$PIDFILE"); then
    +    echo 'Service is running' >&2
    +    return 0
    +  else
    +    echo 'Service is not running' >&2
    +    return 1
    +  fi
    +}
    +
    +case "$1" in
    +  start)
    +    start
    +    ;;
    +  stop)
    +    stop
    +    ;;
    +  status)
    +    status
    +    ;;
    +  restart)
    +    stop
    +    start
    +    ;;
    +  *)
    +    echo "Usage: $0 {start|stop|restart|status}"
    +esac
    - change mode from '' to '0744'
    - change owner from '' to 'root'
    - change group from '' to 'root'
    - restore selinux security context
  * service[automate-liveness-agent] action enable
    - enable service service[automate-liveness-agent]
  * service[automate-liveness-agent] action start
    - start service service[automate-liveness-agent]
Recipe: sonarqube::default
  * service[sonarqube] action restart
    - restart service service[sonarqube]
Recipe: <Dynamically Defined Resource>
  * service[automate-liveness-agent] action restart
    - restart service service[automate-liveness-agent]

Running handlers:
Running handlers complete
Chef Client finished, 26/31 resources updated in 47 seconds
